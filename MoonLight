if game.PlaceId == 17625359962 then
local ReGui = loadstring(game:HttpGet('https://raw.githubusercontent.com/depthso/Dear-ReGui/refs/heads/main/ReGui.lua'))()
local PrefabsId = `rbxassetid://{ReGui.PrefabsId}`

--// Externally import the Prefabs asset
ReGui:Init({
	Prefabs = game:GetService("InsertService"):LoadLocalAsset(PrefabsId)
})



ReGui:DefineTheme("Cherry", {
	TitleAlign = Enum.TextXAlignment.Center,
	TextDisabled = Color3.fromRGB(120, 100, 120),
	Text = Color3.fromRGB(200, 180, 200),
	
	FrameBg = Color3.fromRGB(25, 20, 25),
	FrameBgTransparency = 0.4,
	FrameBgActive = Color3.fromRGB(120, 100, 120),
	FrameBgTransparencyActive = 0.4,
	
	CheckMark = Color3.fromRGB(150, 100, 150),
	SliderGrab = Color3.fromRGB(150, 100, 150),
	ButtonsBg = Color3.fromRGB(150, 100, 150),
	CollapsingHeaderBg = Color3.fromRGB(150, 100, 150),
	CollapsingHeaderText = Color3.fromRGB(200, 180, 200),
	RadioButtonHoveredBg = Color3.fromRGB(150, 100, 150),
	
	WindowBg = Color3.fromRGB(35, 30, 35),
	TitleBarBg = Color3.fromRGB(35, 30, 35),
	TitleBarBgActive = Color3.fromRGB(50, 45, 50),
	
	Border = Color3.fromRGB(50, 45, 50),
	ResizeGrab = Color3.fromRGB(50, 45, 50),
	RegionBgTransparency = 1,
	Tab = Color3.fromRGB(50, 45, 50),
})





local Window = ReGui:Window({
	Title = "Key system",
	Size = UDim2.fromOffset(300, 100),
	NoCollapse = true,
	NoResize = true,
	Theme = "Cherry",
	NoClose = true
}):Center()

local Key = Window:InputText({
	Label = "Key",
	PlaceHolder = "Key here",
	Value = "",
})

Window:Button({
	Text = "Enter",
	Callback = function()
		-- Successful
		if Key:GetValue() == "MoonLightTop" then
		Window:Close()
			do --// Tabs window demo
	
	
		
	


type Button = {
	Text: string?,
	Callback: ((...any) -> unknown)?
}



type RadioButton = {
	Label: string?,
	IsRadio: boolean?,
	Value: boolean,
	NoAnimation: boolean?,
	Callback: ((...any) -> unknown)?,
	SetTicked: (self: Checkbox, Value: boolean, NoAnimation: boolean) -> ...any,
	Toggle: (self: Checkbox) -> ...any
}
	













--Name ESP
local Players = game:GetService("Players")

local nameTags = {}
local nameEnabled = true

local function createESP(player)
    if player == Players.LocalPlayer then return end -- Pomija lokalnego gracza

    local function onCharacterAdded(character)
        local head = character:FindFirstChild("Head")
        if not head then return end

        -- Tworzenie BillboardGui dla nazwy
        local billboard = Instance.new("BillboardGui")
        billboard.Adornee = head
        billboard.Size = UDim2.new(0, 100, 0, 30) -- Przywrócony oryginalny rozmiar
        billboard.StudsOffset = Vector3.new(0, 2, 0) -- Pozycja nad głową
        billboard.AlwaysOnTop = true
        billboard.Enabled = nameEnabled

        local textLabel = Instance.new("TextLabel")
        textLabel.Parent = billboard
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.BackgroundTransparency = 1
        textLabel.Text = player.Name
        textLabel.TextColor3 = Color3.fromRGB(255, 255, 255) -- Biały tekst
        textLabel.TextStrokeTransparency = 0 -- Widoczna obwódka
        textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0) -- Czarna obwódka
        textLabel.TextScaled = true
        textLabel.Font = Enum.Font.SourceSansBold

        billboard.Parent = character
        nameTags[player] = billboard
    end

    -- Jeśli gracz ma już postać, dodajemy ESP
    if player.Character then
        onCharacterAdded(player.Character)
    end

    -- Nasłuchiwanie na odradzanie się gracza
    player.CharacterAdded:Connect(onCharacterAdded)
end

-- Włączanie i wyłączanie ESP
function enableName()
    nameEnabled = true
    for _, tag in pairs(nameTags) do
        if tag then
            tag.Enabled = true
        end
    end
end

function disableName()
    nameEnabled = false
    for _, tag in pairs(nameTags) do
        if tag then
            tag.Enabled = false
        end
    end
end

-- Dodajemy ESP dla istniejących graczy
for _, player in pairs(Players:GetPlayers()) do
    createESP(player)
end

-- Dodajemy ESP dla nowych graczy
Players.PlayerAdded:Connect(function(player)
    createESP(player)
end)


































--BOX
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- Przechowujemy ESP Boxy
local espBoxes = {}

local function createESPBox(player)
    if player == LocalPlayer then return end -- Nie rysuj ESP dla siebie

    local box = Drawing.new("Square")
    local outerBox1 = Drawing.new("Square") -- Zewnętrzna obwódka
    local outerBox2 = Drawing.new("Square") -- Wewnętrzna obwódka

    local thickness = 2
    local borderThickness = thickness * 0.5 -- Obwódka 0.5x cieńsza niż główny box

    -- Główne ESP Boxy (Białe)
    box.Thickness = thickness
    box.Color = Color3.fromRGB(255, 255, 255) -- Biały kolor
    box.Filled = false
    box.Visible = false

    -- Obwódka zewnętrzna (Czarna)
    outerBox1.Thickness = borderThickness
    outerBox1.Color = Color3.fromRGB(0, 0, 0) -- Czarna obwódka
    outerBox1.Filled = false
    outerBox1.Visible = false

    -- Obwódka wewnętrzna (Czarna)
    outerBox2.Thickness = borderThickness
    outerBox2.Color = Color3.fromRGB(0, 0, 0) -- Czarna obwódka
    outerBox2.Filled = false
    outerBox2.Visible = false

    local function update()
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = player.Character.HumanoidRootPart
            local head = player.Character:FindFirstChild("Head")

            if head then
                local headPos, headOnScreen = Camera:WorldToViewportPoint(head.Position)
                local rootPos, rootOnScreen = Camera:WorldToViewportPoint(rootPart.Position)

                if headOnScreen and rootOnScreen then
                    -- Obliczanie wysokości i szerokości boxu na podstawie pozycji głowy i ciała
                    local height = math.abs(headPos.Y - rootPos.Y)
                    local width = height * 0.6 -- Dopasowanie proporcji do gracza

                    -- Zwiększenie wysokości i szerokości boxów
                    local boxSize = Vector2.new(width * 3, height * 4)
                    local boxPos = Vector2.new(rootPos.X - boxSize.X / 2, rootPos.Y - boxSize.Y / 2)

                    box.Size = boxSize
                    box.Position = boxPos

                    -- Obwódka na zewnątrz (większa)
                    outerBox1.Size = boxSize + Vector2.new(borderThickness * 2, borderThickness * 2)
                    outerBox1.Position = boxPos - Vector2.new(borderThickness, borderThickness)

                    -- Obwódka wewnętrzna (mniejsza)
                    outerBox2.Size = boxSize - Vector2.new(borderThickness * 2, borderThickness * 2)
                    outerBox2.Position = boxPos + Vector2.new(borderThickness, borderThickness)

                    -- Ustawienie widoczności
                    box.Visible = true
                    outerBox1.Visible = true
                    outerBox2.Visible = true
                else
                    box.Visible = false
                    outerBox1.Visible = false
                    outerBox2.Visible = false
                end
            end
        else
            box.Visible = false
            outerBox1.Visible = false
            outerBox2.Visible = false
        end
    end

    RunService.RenderStepped:Connect(update)

    -- Przechowujemy ESP Boxy w tabeli
    espBoxes[player.UserId] = {box = box, outerBox1 = outerBox1, outerBox2 = outerBox2}
end

-- Funkcja włączająca ESP Boxy
local function enableBox()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and not espBoxes[player.UserId] then
            createESPBox(player)
        end
    end
end

-- Funkcja wyłączająca ESP Boxy
local function disableBox()
    for _, player in pairs(Players:GetPlayers()) do
        local boxes = espBoxes[player.UserId]
        if boxes then
            boxes.box:Remove()        -- Usuwa główny box
            boxes.outerBox1:Remove()  -- Usuwa zewnętrzną obwódkę
            boxes.outerBox2:Remove()  -- Usuwa wewnętrzną obwódkę
            espBoxes[player.UserId] = nil  -- Usuwamy z tabeli
        end
    end
end

-- Dodanie ESP Boxów dla istniejących graczy
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        createESPBox(player)
    end
end

-- Dodanie ESP Boxów dla nowych graczy
Players.PlayerAdded:Connect(function(player)
    createESPBox(player)
end)

-- Przykład użycia:
-- enableBox()  -- Włącza ESP Boxy dla wszystkich graczy
-- disableBox() -- Wyłącza ESP Boxy dla wszystkich graczy
































--healthbar
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Przechowujemy informacje o Health Barach
local healthBars = {}

local function createHealthBar(player)
    if player == Players.LocalPlayer then return end -- Pomija lokalnego gracza

    local function onCharacterAdded(character)
        local head = character:FindFirstChild("Head")
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not head or not humanoid then return end

        -- Tworzenie BillboardGui dla Health Bara
        local billboard = Instance.new("BillboardGui")
        billboard.Adornee = head
        billboard.Size = UDim2.new(1, 0, 3, 0)
        billboard.StudsOffset = Vector3.new(2, -2, 0) -- Pasek zdrowia obok gracza (w prawo)
        billboard.AlwaysOnTop = true

        -- Tło paska zdrowia (czarne)
        local background = Instance.new("Frame")
        background.Size = UDim2.new(0.3, 0, 1, 0)
        background.Position = UDim2.new(0.5, 0, 0, 0)
        background.AnchorPoint = Vector2.new(0.5, 0)
        background.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        background.BorderSizePixel = 0
        background.Parent = billboard

        -- Pasek zdrowia (dynamiczny)
        local healthBar = Instance.new("Frame")
        healthBar.Size = UDim2.new(1, 0, 1, 0)
        healthBar.BackgroundColor3 = Color3.fromRGB(0, 255, 0) -- Zielony pasek
        healthBar.BorderSizePixel = 0
        healthBar.Position = UDim2.new(0, 0, 1, 0) -- Startuje na dole
        healthBar.AnchorPoint = Vector2.new(0, 1)
        healthBar.Parent = background

        -- Aktualizacja paska zdrowia
        local function updateHealth()
            if humanoid and healthBar then
                local healthPercent = humanoid.Health / humanoid.MaxHealth
                healthBar.Size = UDim2.new(1, 0, healthPercent, 0)

                -- Zmiana koloru w zależności od HP
                if healthPercent > 0.6 then
                    healthBar.BackgroundColor3 = Color3.fromRGB(0, 255, 0) -- Zielony
                elseif healthPercent > 0.3 then
                    healthBar.BackgroundColor3 = Color3.fromRGB(255, 165, 0) -- Pomarańczowy
                else
                    healthBar.BackgroundColor3 = Color3.fromRGB(255, 0, 0) -- Czerwony
                end
            end
        end

        -- Aktualizuje pasek zdrowia co klatkę
        local connection
        connection = RunService.RenderStepped:Connect(function()
            if humanoid.Health <= 0 then
                connection:Disconnect() -- Przestaje aktualizować po śmierci
                billboard:Destroy() -- Usuwa pasek zdrowia
            else
                updateHealth()
            end
        end)

        billboard.Parent = character

        -- Przechowywanie BillboardGui (Health Bar) w tabeli
        healthBars[player.UserId] = billboard
    end

    -- Jeśli gracz ma już postać, dodajemy Health Bar
    if player.Character then
        onCharacterAdded(player.Character)
    end

    -- Nasłuchiwanie na odradzanie się gracza
    player.CharacterAdded:Connect(onCharacterAdded)
end

-- Dodajemy Health Bar dla istniejących graczy
for _, player in pairs(Players:GetPlayers()) do
    createHealthBar(player)
end

-- Dodajemy Health Bar dla nowych graczy
Players.PlayerAdded:Connect(function(player)
    createHealthBar(player)
end)

-- Funkcja włączająca Health Bar ESP dla gracza
local function enableHealth()
    for _, player in pairs(Players:GetPlayers()) do
        if not healthBars[player.UserId] then
            createHealthBar(player)
        end
    end
end

-- Funkcja wyłączająca Health Bar ESP dla gracza
local function disableHealth()
    for _, player in pairs(Players:GetPlayers()) do
        local billboard = healthBars[player.UserId]
        if billboard then
            billboard:Destroy()  -- Usuwamy Health Bar
            healthBars[player.UserId] = nil  -- Usuwamy z tabeli
        end
    end
end

-- Przykład wywołania: Możesz włączyć lub wyłączyć Health Bar ESP
-- enableHealth()  -- Włącza Health Bar dla wszystkich graczy
-- disableHealth() -- Wyłącza Health Bar dla wszystkich graczy
























--kolorowyswiat
local function enablePurple()


local Lighting = game:GetService("Lighting")

-- Sprawdzenie, czy istnieje już Sky, jeśli nie, to dodajemy nowy
local sky = Lighting:FindFirstChildOfClass("Sky")
if not sky then
    sky = Instance.new("Sky")
    sky.Parent = Lighting
end

-- Ustawienie fioletowego nieba
sky.SkyboxUp = "rbxassetid://5917331294"   -- Tekstura nieba (możesz zmienić ID)
sky.SkyboxDn = "rbxassetid://5917331294"
sky.SkyboxLf = "rbxassetid://5917331294"
sky.SkyboxRt = "rbxassetid://5917331294"
sky.SkyboxFt = "rbxassetid://5917331294"
sky.SkyboxBk = "rbxassetid://5917331294"

-- Możesz też zmienić kolor otoczenia dla lepszego efektu
Lighting.Ambient = Color3.fromRGB(128, 0, 128)  -- Fioletowe oświetlenie
Lighting.OutdoorAmbient = Color3.fromRGB(100, 0, 150)  -- Ciemniejszy fiolet na zewnątrz

end

local function disablePurple()


local Lighting = game:GetService("Lighting")

-- Sprawdzenie, czy istnieje już Sky, jeśli nie, to dodajemy nowy
local sky = Lighting:FindFirstChildOfClass("Sky")
if not sky then
    sky = Instance.new("Sky")
    sky.Parent = Lighting
end

-- Ustawienie fioletowego nieba
sky.SkyboxUp = "rbxassetid://5917331294"   -- Tekstura nieba (możesz zmienić ID)
sky.SkyboxDn = "rbxassetid://5917331294"
sky.SkyboxLf = "rbxassetid://5917331294"
sky.SkyboxRt = "rbxassetid://5917331294"
sky.SkyboxFt = "rbxassetid://5917331294"
sky.SkyboxBk = "rbxassetid://5917331294"

-- Możesz też zmienić kolor otoczenia dla lepszego efektu
Lighting.Ambient = Color3.fromRGB(128, 128, 128)  -- Fioletowe oświetlenie
Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)  -- Ciemniejszy fiolet na zewnątrz

end






















--noclip
--local userInputService = game:GetService("UserInputService")
--local runService = game:GetService("RunService")
--local players = game:GetService("Players")
--local player = players.LocalPlayer

--local baseFlySpeed = 50
--local turboMultiplier = 5
--local flying = false
--local bodyVelocity
--local noclipConnection
--local renderConnection
--local character, humanoid, humanoidRootPart

-- Pobieranie postaci po respawnie
--local function setupCharacter()
    --character = player.Character or player.CharacterAdded:Wait()
    --humanoid = character:WaitForChild("Humanoid")
    --humanoidRootPart = character:WaitForChild("HumanoidRootPart")
--end

--setupCharacter()

-- Funkcja do włączania/wyłączania kolizji
--local function toggleNoclip(state)
    --for _, part in pairs(character:GetDescendants()) do
        --if part:IsA("BasePart") then
            --part.CanCollide = not state
        --end
    --end
--end

-- Rozpoczęcie latania
--local function enableFly()
    --if flying then return end
    --flying = true

    --humanoid.PlatformStand = true
    --toggleNoclip(true)

    --bodyVelocity = Instance.new("BodyVelocity")
    --bodyVelocity.Velocity = Vector3.zero
    --bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    --bodyVelocity.Parent = humanoidRootPart

    --noclipConnection = runService.Stepped:Connect(function()
        --toggleNoclip(true)
    --end)

    --renderConnection = runService.RenderStepped:Connect(function()
        --if not flying then return end
        --local moveDirection = Vector3.zero

       -- if userInputService:IsKeyDown(Enum.KeyCode.W) then
         --   moveDirection += humanoidRootPart.CFrame.LookVector
      --  end
      --  if userInputService:IsKeyDown(Enum.KeyCode.S) then
       --     moveDirection -= humanoidRootPart.CFrame.LookVector
       -- end
       -- if userInputService:IsKeyDown(Enum.KeyCode.A) then
         --   moveDirection -= humanoidRootPart.CFrame.RightVector
      --  end
      --  if userInputService:IsKeyDown(Enum.KeyCode.D) then
        --    moveDirection += humanoidRootPart.CFrame.RightVector
      --  end
      --  if userInputService:IsKeyDown(Enum.KeyCode.Space) then
        --    moveDirection += Vector3.new(0, 1, 0)
      --  end
      --  if userInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
        --    moveDirection -= Vector3.new(0, 1, 0)
      --  end

       -- local flySpeed = baseFlySpeed
       -- if userInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
         --   flySpeed *= turboMultiplier
       -- end

        --if moveDirection.Magnitude > 0 then
        --    bodyVelocity.Velocity = moveDirection.Unit * flySpeed
       -- else
          --  bodyVelocity.Velocity = Vector3.zero
       -- end
   -- end)
--end

-- Zatrzymanie latania
--local function disableFly()
--    if not flying then return end
 --   flying = false
--    humanoid.PlatformStand = false
 --   toggleNoclip(false)

--    if bodyVelocity then
--        bodyVelocity:Destroy()
 --       bodyVelocity = nil
--    end
--    if noclipConnection then
--        noclipConnection:Disconnect()
  --      noclipConnection = nil
--    end
--    if renderConnection then
  --      renderConnection:Disconnect()
  --      renderConnection = nil
   -- end
--end

-- Automatycznie uruchamia latanie po załadowaniu skryptu
--enableFly()

-- Po śmierci gracza resetujemy latanie
--player.CharacterAdded:Connect(function()
 --   setupCharacter()
  --  disableFly()
--toggleNoclip(false)
--end)






















	--aimbot
	local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local FOV_RADIUS = 100
local AIMBOT_ENABLED = false
local fovCircle

-- Zmienne do przechowywania połączeń
local renderSteppedConnection
local inputBeganConnection
local inputEndedConnection

local function createFOVCircle()
    if fovCircle then
        fovCircle:Remove()
    end

    fovCircle = Drawing.new("Circle")
    fovCircle.Color = Color3.new(1, 1, 1)
    fovCircle.Thickness = 1
    fovCircle.Radius = FOV_RADIUS
    fovCircle.Filled = false
    fovCircle.Visible = true
end

local function getClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = FOV_RADIUS
    local mouseLocation = UserInputService:GetMouseLocation()
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            local headPosition = Camera:WorldToViewportPoint(player.Character.Head.Position)
            local screenPosition = Vector2.new(headPosition.X, headPosition.Y)
            local distance = (screenPosition - mouseLocation).Magnitude
            
            if distance < shortestDistance then
                closestPlayer = player
                shortestDistance = distance
            end
        end
    end
    
    return closestPlayer
end

local function enableAimbot()
    createFOVCircle()

    renderSteppedConnection = RunService.RenderStepped:Connect(function()
        if fovCircle then
            fovCircle.Position = UserInputService:GetMouseLocation()
        end

        if AIMBOT_ENABLED then
            local target = getClosestPlayer()
            if target and target.Character and target.Character:FindFirstChild("Head") then
                local headPosition = Camera:WorldToViewportPoint(target.Character.Head.Position)
                mousemoverel((headPosition.X - UserInputService:GetMouseLocation().X) / 2, (headPosition.Y - UserInputService:GetMouseLocation().Y) / 2)
            end
        end
    end)

    inputBeganConnection = UserInputService.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton2 then
            AIMBOT_ENABLED = true
        end
    end)

    inputEndedConnection = UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton2 then
            AIMBOT_ENABLED = false
        end
    end)
end

local function disableAimbot()
    if renderSteppedConnection then renderSteppedConnection:Disconnect() end
    if inputBeganConnection then inputBeganConnection:Disconnect() end
    if inputEndedConnection then inputEndedConnection:Disconnect() end

    if fovCircle then
        fovCircle:Remove()
        fovCircle = nil
    end

    AIMBOT_ENABLED = false
end

	
	







--update
function updateFOV()
    if not fovCircle then
        createFOVCircle() -- Tworzy nowy okrąg, jeśli nie istnieje
    end
    fovCircle.Visible = false  
    fovCircle.Radius = FOV_RADIUS  
    fovCircle.Visible = true   
end










--trigger
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local Camera = game:GetService("Workspace").CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local TRIGGER_ACTIVE = false  -- Czy TriggerBot jest aktywny?

-- Przechowywanie połączeń, aby można było je wyłączyć
local inputBeganConnection
local inputEndedConnection
local triggerLoop

local function isEnemy(target)
    if target and target.Parent then
        local character = target.Parent
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        return humanoid and character ~= LocalPlayer.Character
    end
    return false
end

local function triggerShoot()
    if Mouse.Target and isEnemy(Mouse.Target) then
        mouse1press()
        wait(0.05)
        mouse1release()
    end
end

local function enableTriggerBot()
    if inputBeganConnection or inputEndedConnection or triggerLoop then return end

    inputBeganConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.UserInputType == Enum.UserInputType.MouseButton2 then  -- PPM naciśnięty
            TRIGGER_ACTIVE = true
            triggerLoop = task.spawn(function()
                while TRIGGER_ACTIVE do
                    triggerShoot()
                    task.wait(0.01)  -- Szybkie strzelanie
                end
            end)
        end
    end)

    inputEndedConnection = UserInputService.InputEnded:Connect(function(input, gameProcessed)
        if input.UserInputType == Enum.UserInputType.MouseButton2 then  -- PPM puszczony
            TRIGGER_ACTIVE = false
        end
    end)
end

local function disableTriggerBot()
    if inputBeganConnection then inputBeganConnection:Disconnect() inputBeganConnection = nil end
    if inputEndedConnection then inputEndedConnection:Disconnect() inputEndedConnection = nil end
    if triggerLoop then task.cancel(triggerLoop) triggerLoop = nil end
    TRIGGER_ACTIVE = false
end

-- Funkcja do przełączania TriggerBota










local ModalWindow = Window:PopupModal({
	Title = "MoonLight Info",
	AutoSize = "Y"
})
	
	ModalWindow:Label({
	Text = [[Last Update 17.03.2025]],
	TextWrapped = true
})
ModalWindow:Separator()

ModalWindow:Button({
	Text = "Okay",
	Callback = function()
		ModalWindow:ClosePopup()
	end,
})
	
	
	
	local Window = ReGui:TabsWindow({
		Title = "MoonLight",
		Size = UDim2.fromOffset(600, 400),
		Theme = "Cherry",
		NoResize = true,
		NoCollapse = true,
		NoClose = true
		
		
	}):Center()
	
	
	local Tab1 = Window:CreateTab({Name=`Combat`})
	Tab1:Label({
		
		Text = `aimbot tab`

		})
	
	Tab1:Checkbox({
	Value = false,
	Label = "AimBot",
	Callback = function(self, Value: boolean)
		if Value == true then
			enableAimbot()
		end	
		if Value == false then
			disableAimbot()
		end
end
})

Tab1:Checkbox({
	Value = false,
	Label = "TriggerBot",
	Callback = function(self, Value: boolean)
		if Value == true then
			enableTriggerBot()
		end	
		if Value == false then
			disableTriggerBot()
		end
end
})

Tab1:SliderInt({
	Label = "FOV Size",
 	Value = 100,
	Minimum = 50,
	Maximum = 500,
	Callback = function(self, Value)
	FOV_RADIUS = Value
	updateFOV()

	end,
})






	local Tab2 = Window:CreateTab({Name=`Visuals`})
	Tab2:Label({
		
		Text = `esp tab`

		})

	Tab2:Checkbox({
	Value = false,
	Label = "HighLights",
	Callback = function(self, Value: boolean)
		if Value == true then
											local Players = game:GetService("Players")

											local function createBoxAroundCharacter(character)
												-- Sprawdź, czy postać istnieje
												if not character or not character:FindFirstChild("HumanoidRootPart") then return end

												-- Usuń istniejący Highlight, aby uniknąć duplikatów
												local existingHighlight = character:FindFirstChildOfClass("Highlight")
												if existingHighlight then
													existingHighlight:Destroy()
												end

												-- Tworzenie nowego Highlight
												local highlight = Instance.new("Highlight")
												highlight.Adornee = character
												highlight.Parent = character
												highlight.FillColor = Color3.fromRGB(213, 52, 235) 
												highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
											end

											local function onPlayerAdded(player)
												-- Nasłuchuj, kiedy postać zostanie dodana
												player.CharacterAdded:Connect(function(character)
													-- Odczekaj chwilę, aby upewnić się, że postać została załadowana
													task.wait(0.5)
													createBoxAroundCharacter(character)
												end)
											end

											-- Dodanie highlighta dla już obecnych graczy
											for _, player in ipairs(Players:GetPlayers()) do
												if player.Character then
													createBoxAroundCharacter(player.Character)
												end
												onPlayerAdded(player)
											end

											-- Obsługa nowych graczy
											Players.PlayerAdded:Connect(onPlayerAdded)


		end
		if Value == false then
		loadstring(game:HttpGet("https://pastebin.com/raw/EYdMXKW1"))()
		end
	
	end
})




Tab2:Checkbox({
	Value = false,
	Label = "Box ESP",
	Callback = function(self, Value: boolean)
		if Value == true then
			enableBox()
		end	
		if Value == false then
			disableBox()
		end
end
})







Tab2:Checkbox({
	Value = false,
	Label = "Health Bar",
	Callback = function(self, Value: boolean)
		if Value == true then
			enableHealth()
		end	
		if Value == false then
			disableHealth()
		end
end
})


Tab2:Checkbox({
	Value = false,
	Label = "Name Tag",
	Callback = function(self, Value: boolean)
		if Value == true then
			enableName()
		end	
		if Value == false then
			disableName()
		end
end
})







local Tab3 = Window:CreateTab({Name=`Other`})
	Tab3:Label({
		
		Text = `other tab`

		})



Tab3:Checkbox({
	Value = false,
	Label = "NoClip",
	Callback = function(self, Value: boolean)
		if Value == true then
			--enableFly()
		end	
		if Value == false then
			--disableFly()
		end
end
})



Tab3:Checkbox({
	Value = false,
	Label = "Purple World",
	Callback = function(self, Value: boolean)
		if Value == true then
			enablePurple()
		end	
		if Value == false then
			disablePurple()
		end
end
})




local Tab4 = Window:CreateTab({Name=`Settings`})
	Tab4:Label({
		
		Text = `.gg/E4uF2TeSpe   [9009]`

		})




Tab4:Keybind({
    Label = "Gui Key",
    Value = Enum.KeyCode.Insert,
    Callback = function(_, NewKeybind)
        local IsVisible = Window.Visible
        Window:SetVisible(not IsVisible)
    end
})
local Settings = CreateTab("Setttings", ReGui.Icons.Settings)

	
	
end			-- Unsuccessful
		else
			Key:SetLabel("Wrong key!")
		end
	end,
})



end--nie zmieniac 
